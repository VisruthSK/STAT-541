{
  "hash": "bd0600c46dcecc00cbfd9e44d4caf640",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab 6 - Spicy\"\ndescription: \"Fancy Functions\"\ndate: \"2025.05.12\"\nimage: thumbnail.png\n---\n\nThis assignment will challenge your function writing abilities. I'm not going \nto lie, these functions are difficult but well within your reach. I do, however,\nwant to recognize that not everyone is interested in being a \"virtuoso\" with \ntheir function writing. So, there are two options for this week's lab:\n\n- **Option 1:** Complete this lab assignment in search of virtuoso status with\nyour function writing\n- **Option 2:** Complete one of the difficult functions (Exercise 1 or Exercise 2) and complete the \"Alternative Lab 6\". \n\n# Setting the Stage\n\nMy number one use case for writing functions and iteration / looping is to\nperform some exploration or modeling repeatedly for different \"tweaked\"\nversions. For example, our broad goal might be to fit a linear regression model\nto our data. However, there are often multiple choices that we have to make in\npractice:\n\n- Keep missing values or fill them in (imputation)? \n- Filter out outliers in one or more variables?\n\nWe can map these choices to **arguments** in a custom model-fitting function:\n\n- `impute`: TRUE or FALSE\n- `remove_outliers`: TRUE or FALSE\n\nA function that implements the analysis and allows for variation in these \nchoices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(df, impute, remove_outliers, mod) {\n  if (impute) {\n    df <- some_imputation_function(df)\n  }\n\n  if (remove_outliers) {\n    df <- function_for_removing_outliers(df)\n  }\n\n  lm(mod, data = df)\n}\n```\n:::\n\n\n# Helper Functions\n\n**Exercise 1:** Write a function that removes outliers in a dataset. The user\nshould be able to supply the dataset, the variables to remove outliers from, and\na threshold on the number of SDs away from the mean used to define outliers. \n*Hint 1: You will need to calculate a z-score to filter the values!*\n*Hint 2: You might want to consider specifying a default value (e.g., 3) for `sd_thresh`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nuse(\"glue\", \"glue\")\nuse(\"cli\", \"cli_warn\")\n\nremove_outliers <- function(data, ..., sd_thresh = 3) {\n  data |>\n    filter(\n      if_all(\n        c(...),\n        \\(col) {\n          if (!is.numeric(col)) {\n            # TODO: use a native function instead of `deparse(substitute())`\n            cli_warn(glue(\n              \"{deparse(substitute(col))} is not a numeric column and will be ignored.\"\n            ))\n            return(TRUE)\n          }\n          abs((col - mean(col, na.rm = TRUE)) / sd(col, TRUE)) <= sd_thresh\n        }\n      )\n    )\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nremove_outliers(diamonds, price, x, y, z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,689 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,679 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nremove_outliers(diamonds, price, color)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `filter()`.\nℹ In argument: `&...`.\nCaused by warning:\n! color is not a numeric column and will be ignored.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 52,734 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 52,724 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default sd_thresh\nremove_outliers(diamonds, price, x, y, z, sd_thresh = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 50,099 × 10\n   carat cut       color clarity depth table price     x     y     z\n   <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.23 Ideal     E     SI2      61.5    55   326  3.95  3.98  2.43\n 2  0.21 Premium   E     SI1      59.8    61   326  3.89  3.84  2.31\n 3  0.23 Good      E     VS1      56.9    65   327  4.05  4.07  2.31\n 4  0.29 Premium   I     VS2      62.4    58   334  4.2   4.23  2.63\n 5  0.31 Good      J     SI2      63.3    58   335  4.34  4.35  2.75\n 6  0.24 Very Good J     VVS2     62.8    57   336  3.94  3.96  2.48\n 7  0.24 Very Good I     VVS1     62.3    57   336  3.95  3.98  2.47\n 8  0.26 Very Good H     SI1      61.9    55   337  4.07  4.11  2.53\n 9  0.22 Fair      E     VS2      65.1    61   337  3.87  3.78  2.49\n10  0.23 Very Good H     VS1      59.4    61   338  4     4.05  2.39\n# ℹ 50,089 more rows\n```\n\n\n:::\n:::\n\n\n**Exercise 2:** Write a function that imputes missing values for numeric \nvariables in a dataset. The user should be able to supply the dataset, the \nvariables to impute values for, and a function to use when imputing. \n*Hint 1: You will need to use `across()` to apply your function, since the user can input multiple variables.*\n*Hint 2: The `replace_na()` function is helpful here!*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimpute_missing <- function(data, ..., impute_fun = mean) {\n  data |>\n    mutate(across(c(...), \\(col) {\n      if (!is.numeric(col)) {\n        cli_warn(glue(\n          \"{cur_column()} is not a numeric column and will be ignored.\"\n        ))\n        return(col)\n      }\n      replace_na(col, impute_fun(col, na.rm = TRUE))\n    }))\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Testing how your function handles multiple input variables\nimpute_missing(nycflights13::flights, arr_delay, dep_delay)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles an input that isn't numeric\nimpute_missing(nycflights13::flights, arr_delay, carrier)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\nℹ In argument: `across(...)`.\nCaused by warning:\n! carrier is not a numeric column and will be ignored.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n## Testing how your function handles a non-default impute_fun\nimpute_missing(nycflights13::flights, arr_delay, dep_delay, impute_fun = median)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n# Primary Function\n\n**Exercise 3:** Write a `fit_model()` function that fits a specified linear\nregression model for a specified dataset. The function should:\n\n- allow the user to specify if outliers should be removed (`TRUE` or `FALSE`)\n- allow the user to specify if missing observations should be imputed\n(`TRUE` or `FALSE`)\n\nIf either option is `TRUE`, your function should call your `remove_outliers()`\nor `impute_missing()` functions to modify the data **before** the regression \nmodel is fit. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model <- function(data, mod_formula, remove_outliers, impute_missing, ...) {\n  data |>\n    (\\(data) {\n      if (remove_outliers) data <- remove_outliers(data, ...)\n      if (impute_missing) data <- impute_missing(data, ...)\n      data\n    })() |>\n    lm(mod_formula, data = _)\n}\n```\n:::\n\n\n## Testing Your Function! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_model(\n  diamonds,\n  mod_formula = price ~ carat + cut,\n  remove_outliers = TRUE,\n  impute_missing = TRUE,\n  price,\n  carat\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2460.16      7526.96      1059.65      -410.54       295.80        82.62  \n```\n\n\n:::\n:::\n\n\n# Iteration\n\nIn the `diamonds` dataset, we want to understand the relationship between\n`price` and size (`carat`). We want to explore variation along two choices:\n\n1. The variables included in the model. We'll explore 3 sets of variables:\n    - No further variables (just `price` and `carat`)\n    - Adjusting for `cut`\n    - Adjusting for `cut` and `clarity`\n    - Adjusting for `cut`, `clarity`, and `color`\n\n2. Whether or not to impute missing values\n\n3. Whether or not to remove outliers in the `carat` variable (we'll define\noutliers as cases whose `carat` is over 3 SDs away from the mean).\n\n## Parameters\n\nFirst, we need to define the set of parameters we want to iterate the\n`fit_model()` function over. The `tidyr` package has a useful function called\n`crossing()` that is useful for generating argument combinations. For each\nargument, we specify all possible values for that argument and `crossing()` \ngenerates all combinations. \n*Note that you can create a list of formula objects in R with `c(y ~ x1, y ~ x1 + x2)`.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_arg_combos <- crossing(\n  impute = c(TRUE, FALSE),\n  remove_outliers = c(TRUE, FALSE),\n  mod = c(y ~ x1, y ~ x1 + x2)\n)\ndf_arg_combos\n```\n:::\n\n\n**Exercise 4:** Use `crossing()` to create the data frame of argument\ncombinations for our analyses. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_args <- crossing(\n  mod_formula = c(\n    price ~ carat,\n    price ~ carat + cut,\n    price ~ carat + cut + clarity,\n    price ~ carat + cut + clarity + color\n  ),\n  remove_outliers = c(TRUE, FALSE),\n  impute_missing = c(TRUE, FALSE),\n)\n```\n:::\n\n\n## Iterating Over the Parameters\n\nWe've arrived at the final step! \n\n**Exercise 5:** Use `pmap()` from `purrr` to apply the `fit_model()` function to\nevery combination of arguments from `diamonds`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npmap(model_args, fit_model, data = diamonds, carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[2]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat  \n      -2256         7756  \n\n\n[[3]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat  \n      -2354         7898  \n\n\n[[4]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat  \n      -2354         7898  \n\n\n[[5]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[6]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2701.38      7871.08      1239.80      -528.60       367.91        74.59  \n\n\n[[7]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2782.90      8012.63      1179.04      -465.31       337.40        90.91  \n\n\n[[8]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n   -2782.90      8012.63      1179.04      -465.31       337.40        90.91  \n\n\n[[9]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[10]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3187.540     8472.026      713.804     -334.503      188.482        1.663  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4011.681    -1821.922      917.658     -430.047      257.141       26.909  \n  clarity^7  \n    186.742  \n\n\n[[11]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3211.955     8604.166      693.601     -310.001      176.420        9.009  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3790.470    -1546.330      694.758     -294.293      178.926       56.096  \n  clarity^7  \n    181.933  \n\n\n[[12]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3211.955     8604.166      693.601     -310.001      176.420        9.009  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3790.470    -1546.330      694.758     -294.293      178.926       56.096  \n  clarity^7  \n    181.933  \n\n\n[[13]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[14]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3710.603     8886.129      698.907     -327.686      180.565       -1.207  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   4217.535    -1832.406      923.273     -361.995      216.616        2.105  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    110.340    -1910.288     -627.954     -171.960       21.678      -85.943  \n    color^6  \n    -49.986  \n\n\n[[15]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3724.322     9007.286      675.568     -301.591      167.295        6.644  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3982.636    -1541.736      689.208     -219.693      135.996       32.560  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    104.156    -1925.179     -613.256     -163.611       29.485      -72.600  \n    color^6  \n    -49.973  \n\n\n[[16]]\n\nCall:\nlm(formula = mod_formula, data = (function(data) {\n    if (remove_outliers) \n        data <- remove_outliers(data, ...)\n    if (impute_missing) \n        data <- impute_missing(data, ...)\n    data\n})(data))\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n  -3724.322     9007.286      675.568     -301.591      167.295        6.644  \n  clarity.L    clarity.Q    clarity.C    clarity^4    clarity^5    clarity^6  \n   3982.636    -1541.736      689.208     -219.693      135.996       32.560  \n  clarity^7      color.L      color.Q      color.C      color^4      color^5  \n    104.156    -1925.179     -613.256     -163.611       29.485      -72.600  \n    color^6  \n    -49.973  \n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}